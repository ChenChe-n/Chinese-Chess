#include <iostream>
#include <vector>
#include <array>
#include <thread>
#include <cmath>
#include "配置数据.hpp"
#include "图像.hpp"
#include "工具.hpp"
#include <mutex>
#include <queue>
enum 数据 {
    棋下限=-8,
    无=0, 
    将,
    士, 
    象, 
    马, 
    车, 
    炮, 
    兵,
    棋上限 = 8,
    无效数据=9,
    超出数组范围=10,
    可移动标记=11,
    可吃棋标记=12,
    不可移动标记=13,
};
std::mutex 象棋数据Mutex;
class 象棋数据类
{
private:
    std::array <std::array <char, 9>, 10>初始棋盘 = { {
        {5,4,3,2,1,2,3,4,5},
        {0,0,0,0,0,0,0,0,0},
        {0,6,0,0,0,0,0,6,0},
        {7,0,7,0,7,0,7,0,7},
        {0,0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0,0},
        {-7,0,-7,0,-7,0,-7,0,-7},
        {0,-6,0,0,0,0,0,-6,0},
        {0,0,0,0,0,0,0,0,0},
        {-5,-4,-3,-2,-1,-2,-3,-4,-5}}};
public:
    std::array <std::array <char, 9>, 10>能否移动缓存;
    sf::Vector2i 选取的棋子坐标;
    char 选取的棋子种类 = 0;//棋子种类
    sf::Vector2i 当前鼠标坐标 = {0x0,0x0};
	char 当前方 = 1;
    std::array <std::array <char, 9>, 10> 当前棋子;
    std::vector <std::array <char, 6>> 历史棋 = {};//移动的棋子种类,源x,源y,目标x,目标y,吃掉的棋子种类
	int 重置数据(配置数据类& 配置数据) {
        象棋数据Mutex.lock();
		当前方 = -1;
        选取的棋子种类 = 0;
        配置数据.游戏重开 = false;
        清空能否移动缓存();
        历史棋.clear();  // 清空向量中的元素
        历史棋.shrink_to_fit();  // 释放多余的内存
		for (int i = 0; i < 10; ++i) {
			for (int j = 0; j < 9; ++j) {
                当前棋子[i][j] = 初始棋盘[i][j];
			}
		}
        象棋数据Mutex.unlock();
		return 0;
	}
    char 判断原点偏移后是否有棋(int y,int x) {
        //数组超限
        if (y==0 and x ==0)
        {
            return 数据::无效数据;
        }
        if (x < 0)
        {
            if (选取的棋子坐标.x + x < 0)
            {
                return 数据::超出数组范围;
            }
        }
        if (y < 0)
        {
            if (选取的棋子坐标.y + y < 0)
            {
                return 数据::超出数组范围;
            }
        }
        if (x > 0)
        {
            if (选取的棋子坐标.x + x > 8)
            {
                return 数据::超出数组范围;
            }
        }
        if (y > 0)
        {
            if (选取的棋子坐标.y + y > 9)
            {
                return 数据::超出数组范围;
            }
        }
        //std::cout << "源位置xy:" << 选取的棋子坐标.x << "\t" << 选取的棋子坐标.y << "\n";
        //std::cout << "偏移是xy:" << x << "\t" << y << "\n";
        //std::cout << "遮挡棋子:" <<int(当前棋子[选取的棋子坐标.x + x][选取的棋子坐标.y + y]) << "\n";
        return 当前棋子[选取的棋子坐标.y + y][选取的棋子坐标.x + x];
    }
    void 清空能否移动缓存()
    {
        for (int y = 0; y < 10; y++)
        {
            for (int x = 0; x < 9; x++)
            {
                能否移动缓存[y][x] = 数据::无;
            }
        }
    }
};
void 主循环(配置数据类 &配置数据);
int 显示函数(配置数据类 &配置数据, 象棋数据类& 象棋数据);
int 玩家操作(配置数据类 &配置数据, 象棋数据类& 象棋数据);
int 设置显示比例(配置数据类& 配置数据);
int main() {
    配置数据类 配置数据;
    配置数据.加载配置数据("配置.ini");
    设置显示比例(配置数据);
    主循环(配置数据);
    return 0;
}
std::queue<sf::Event> eventQueue;
std::mutex eventMutex;
int 设置显示比例(配置数据类 & 配置数据) {
    int 显示单元格大小 = 配置数据.贴图大小;
    double 缩放倍数 = 1.0;
    while (显示单元格大小 * 缩放倍数 * 12 < 配置数据.窗口大小y)
    {
        缩放倍数 *= 1.1;
    }
    while (显示单元格大小 * 缩放倍数 * 12 > 配置数据.窗口大小y)
    {
        缩放倍数 *= 0.9;
    }
    while (显示单元格大小 * 缩放倍数 * 10 > 配置数据.窗口大小x)
    {
        缩放倍数 *= 0.9;
    }
    配置数据.显示单元格大小 = 显示单元格大小 * 缩放倍数;
    配置数据.缩放倍数 = 缩放倍数;
    std::cout << "缩放倍数:" << 配置数据.缩放倍数 << "显示单元格大小:" << 配置数据.显示单元格大小 << "\n";
    return 0;
}
void 主循环(配置数据类 &配置数据) {
	// 用于存储窗口事件的队列和互斥量
    象棋数据类 象棋数据;
    std::thread 显示线程(显示函数, std::ref(配置数据),std::ref(象棋数据));
    while (配置数据.程序运行状态) 
    {
        if (配置数据.游戏重开)
        {
            象棋数据.重置数据(配置数据);
        }
        玩家操作(配置数据,象棋数据);
        Sleep(15);
    }
    显示线程.join();
}
int 显示棋子(配置数据类& 配置数据,象棋数据类& 象棋数据, sf::RenderWindow &window,显示类 &图像) {
    int 显示颜色;
    for (int y=0;y<10;y++)
    {
        for (int x = 0; x < 9; x++)
        {
            char 当前格棋子类型 = 象棋数据.当前棋子[y][x];
            //std::cout << y << '\t' << x << "\n";
            //std::cout << int(当前格棋子类型) << "\n";       
            if (当前格棋子类型==0)//判断是否空格
            {
            }
            else
            {
                //判断棋子方
                if (当前格棋子类型 * 配置数据 .棋盘显示方>0)
                {
                    显示颜色 = 0;
                }
                else
                {
                    显示颜色 = 1;
                }
                //显示棋子
                图像.棋子[显示颜色][(std::abs(当前格棋子类型) - 1)].设置精灵位置(((配置数据.棋盘位置x + x) * 配置数据.显示单元格大小), ((配置数据.棋盘位置y+y) * 配置数据.显示单元格大小));
                window.draw(图像.棋子[显示颜色][(std::abs(当前格棋子类型)-1)].精灵);
            }
        }
    }
    //显示提示框
    if (象棋数据.当前方 * 配置数据.棋盘显示方 > 0)
    {
        显示颜色 = 0;
    }
    else
    {
        显示颜色 = 1;
    }
    sf::Vector2f 网格原点 = { 配置数据.棋盘位置x * 配置数据.显示单元格大小, 配置数据.棋盘位置y * 配置数据.显示单元格大小 };
    判断鼠标在网格位置 鼠标选取的网格 = { 象棋数据.当前鼠标坐标, 网格原点, sf::Vector2i{ 配置数据.显示单元格大小, 配置数据.显示单元格大小 } ,sf::Vector2i(9,10) };
    if (!鼠标选取的网格.是否超出网格网格)
    {
        if (鼠标选取的网格.网格位置.y < 10)
        {
            图像.选择框[显示颜色].设置精灵位置((鼠标选取的网格.网格位置.x + 配置数据.棋盘位置x) * 配置数据.显示单元格大小, (鼠标选取的网格.网格位置.y + 配置数据.棋盘位置y) * 配置数据.显示单元格大小);
            window.draw(图像.选择框[显示颜色].精灵);
        }
    }

    
    //显示鼠标拿起的棋子
    if (象棋数据.选取的棋子种类 !=0)
    {
        if (象棋数据.选取的棋子种类 * 配置数据.棋盘显示方 > 0)
        {
            显示颜色 = 0;
        }
        else
        {
            显示颜色 = 1;
        }
        //std::cout << "鼠标x:" << 象棋数据.当前鼠标坐标.x << "\ty" << 象棋数据.当前鼠标坐标.y << "\n";
        图像.棋子[显示颜色][(std::abs(象棋数据.选取的棋子种类))-1].设置精灵位置(象棋数据.当前鼠标坐标.x- 配置数据.显示单元格大小/2, 象棋数据.当前鼠标坐标.y - 配置数据.显示单元格大小 / 2);
        window.draw(图像.棋子[显示颜色][(std::abs(象棋数据.选取的棋子种类))-1].精灵);
    }
    return 0;
}
int 显示函数(配置数据类& 配置数据,象棋数据类& 象棋数据) {
    显示类 图像(配置数据);
    sf::RenderWindow window(sf::VideoMode(配置数据.窗口大小x, 配置数据.窗口大小y), "GAME", sf::Style::Close);;
    计时计数限制运行速度类 time2;
    while (配置数据.程序运行状态) {
		sf::Event event;
		while (window.pollEvent(event)) {
			// 将窗口事件添加到事件队列中
			std::lock_guard<std::mutex> lock(eventMutex);
			eventQueue.push(event);
            象棋数据.当前鼠标坐标 = sf::Mouse::getPosition(window);
		}

        window.clear(sf::Color::Blue);
        window.draw(图像.背景.精灵);
        window.draw(图像.棋盘网格线.精灵);
        for (int y = 0; y < 10; y++)
        {
            for (int x = 0; x < 9; x++)
            {
                if (象棋数据.能否移动缓存[y][x] == 数据::可移动标记)
                {
                    图像.移动提示点.设置精灵位置(((配置数据.棋盘位置x + x) * 配置数据.显示单元格大小), ((配置数据.棋盘位置y + y) * 配置数据.显示单元格大小));
                    window.draw(图像.移动提示点.精灵);
                }
                if (象棋数据.能否移动缓存[y][x] == 数据::可吃棋标记)
                {
                    图像.吃棋提示点.设置精灵位置(((配置数据.棋盘位置x + x) * 配置数据.显示单元格大小), ((配置数据.棋盘位置y + y) * 配置数据.显示单元格大小));
                    window.draw(图像.吃棋提示点.精灵);
                }
            }
        }
        显示棋子(配置数据,象棋数据,window, 图像);

        window.display();
        Sleep(15);
    }
    return 0;
}
int 判断移动合法性(判断鼠标在网格位置 &鼠标网格,象棋数据类& 象棋数据) {
    int 缓存; int 计数;
    int x = 象棋数据.选取的棋子坐标.x;
    int y = 象棋数据.选取的棋子坐标.y;
    象棋数据.能否移动缓存 = 象棋数据.当前棋子;
    switch (abs(象棋数据.选取的棋子种类))
    {
    case 1:

        if (象棋数据.选取的棋子坐标.y >= 1 and 象棋数据.选取的棋子坐标.y <= 2 or 象棋数据.选取的棋子坐标.y >= 8)
        {
            象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y - 1][象棋数据.选取的棋子坐标.x] = 数据::可移动标记;
        }
        if (象棋数据.选取的棋子坐标.y <= 8 and 象棋数据.选取的棋子坐标.y >= 7 or 象棋数据.选取的棋子坐标.y <= 1)
        {
            象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y + 1][象棋数据.选取的棋子坐标.x] = 数据::可移动标记;
        }
        if (象棋数据.选取的棋子坐标.x <= 4)
        {
            象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y][象棋数据.选取的棋子坐标.x + 1] = 数据::可移动标记;
        }
        if (象棋数据.选取的棋子坐标.x >= 4)
        {
            象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y][象棋数据.选取的棋子坐标.x - 1] = 数据::可移动标记;
        }
                

        break;
    case 2:
        //x>>    0-1-2-3-4-5-6-7-8
        //y>>0-1-2-3-4      5-6-7-8-9
        if (y >= 7)
        {
            if (x>=4 and y>=8)
            {
                象棋数据.能否移动缓存[y - 1][x - 1] = 数据::可移动标记;
            }
            if (x>=4 and y<=8)
            {
                象棋数据.能否移动缓存[y + 1][x - 1] = 数据::可移动标记;
            }
            if (x<=4 and y>=8)
            {
                象棋数据.能否移动缓存[y - 1][x + 1] = 数据::可移动标记;
            }
            if (x<=4 and y<=8)
            {
                象棋数据.能否移动缓存[y + 1][x + 1] = 数据::可移动标记;
            }
        }
        if (y <= 2)
        {
            if (x >= 4 and y >= 1)
            {
                象棋数据.能否移动缓存[y - 1][x - 1] = 数据::可移动标记;
            }
            if (x >= 4 and y <= 1)
            {
                象棋数据.能否移动缓存[y + 1][x - 1] = 数据::可移动标记;
            }
            if (x <= 4 and y >= 1)
            {
                象棋数据.能否移动缓存[y - 1][x + 1] = 数据::可移动标记;
            }
            if (x <= 4 and y <= 1)
            {
                象棋数据.能否移动缓存[y + 1][x + 1] = 数据::可移动标记;
            }
        }
        break;
    case 3:
        if ((y <= 4 and y <= 2 and x <= 6) or (y >= 5 and y <= 7 and x <= 6))
        {
            if (象棋数据.判断原点偏移后是否有棋(+1, +1) == 数据::无)
            {
                象棋数据.能否移动缓存[y + 2][x + 2] = 数据::可移动标记;
            }
        }
        if ((y <= 4 and y <= 2 and x >= 2) or (y >= 5 and y <= 7 and x >= 2))
        {
            if (象棋数据.判断原点偏移后是否有棋(+1, -1) == 数据::无)
            {
                象棋数据.能否移动缓存[y + 2][x - 2] = 数据::可移动标记;
            }
        }
        if ((y <= 4 and y >= 2 and x <= 6) or (y >= 5 and y >= 7 and x <= 6))
        {
            if (象棋数据.判断原点偏移后是否有棋(-1, +1) == 数据::无)
            {
                象棋数据.能否移动缓存[y - 2][x + 2] = 数据::可移动标记;
            }
        }
        if ((y <= 4 and y >= 2 and x >= 2) or (y >= 5 and y >= 7 and x >= 2))
        {
            if (象棋数据.判断原点偏移后是否有棋(-1, -1) == 数据::无)
            {
                象棋数据.能否移动缓存[y - 2][x - 2] = 数据::可移动标记;
            }
        }
        break;
    case 4:
        if (y <= 7)
        {
            if (象棋数据.判断原点偏移后是否有棋(1, 0) == 0)
            {
                if (象棋数据.选取的棋子坐标.x <= 7)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y + 2][象棋数据.选取的棋子坐标.x + 1] = 数据::可移动标记;
                }
                if (象棋数据.选取的棋子坐标.x >= 1)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y + 2][象棋数据.选取的棋子坐标.x - 1] = 数据::可移动标记;
                }
            }
        }
        if (y >= 2)
        {
            if (象棋数据.判断原点偏移后是否有棋(-1, 0) == 0)
            {
                if (象棋数据.选取的棋子坐标.x <= 7)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y - 2][象棋数据.选取的棋子坐标.x + 1] = 数据::可移动标记;
                }
                if (象棋数据.选取的棋子坐标.x >= 1)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y - 2][象棋数据.选取的棋子坐标.x - 1] = 数据::可移动标记;
                }
            }
        }
        if (x <= 6)
        {
            if (象棋数据.判断原点偏移后是否有棋(0, 1) == 0)
            {
                if (象棋数据.选取的棋子坐标.y <= 8)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y + 1][象棋数据.选取的棋子坐标.x + 2] = 数据::可移动标记;
                }
                if (象棋数据.选取的棋子坐标.y >= 1)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y - 1][象棋数据.选取的棋子坐标.x + 2] = 数据::可移动标记;
                }
            }
        }
        if (x >= 2)
        {
            if (象棋数据.判断原点偏移后是否有棋(0, -1) == 0)
            {
                if (象棋数据.选取的棋子坐标.y <= 8)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y + 1][象棋数据.选取的棋子坐标.x - 2] = 数据::可移动标记;
                }
                if (象棋数据.选取的棋子坐标.y >= 1)
                {
                    象棋数据.能否移动缓存[象棋数据.选取的棋子坐标.y - 1][象棋数据.选取的棋子坐标.x - 2] = 数据::可移动标记;
                }
            }
        }
        break;
    case 5:
        
        for (int xx = 1; xx < 9-x; xx++)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(0, xx);
            if (缓存 == 数据::无)
            {
                象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
            }
            else if (缓存 != 数据::无)
            {
                象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
                break;
            }
        }
        for (int xx = -1; xx >= -1 * x; xx--)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(0, xx);
            if (缓存 == 数据::无)
            {
                象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
            }
            else if (缓存 != 数据::无)
            {
                象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
                break;
            }
        }
        for (int yy = 1; yy < 10 - y; yy++)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(yy, 0);
            if (缓存 == 数据::无)
            {
                象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
            }
            else if (缓存 != 数据::无)
            {
                象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
                break;
            }
        }
        for (int yy = -1; yy >= -1 * y; yy--)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(yy, 0);
            if (缓存 == 数据::无)
            {
                象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
            }
            else if (缓存 != 数据::无)
            {
                象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
                break;
            }
        }
        break;
    case 6:
        计数 = 0;
        for (int xx = 1; xx < 9 - x; xx++)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(0, xx);
            if (缓存 == 数据::无 and 计数 == 0)
            {
                象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
            }
            if (缓存 != 数据::无 )
            {
                if (计数==1)
                {
                    象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
                    break;
                }
                计数++;
            }
        }
        计数 = 0;
        for (int xx = -1; xx >= -1 * x; xx--)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(0, xx);
            if (缓存 == 数据::无 and 计数 == 0)
            {
                象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
            }
            if (缓存 != 数据::无)
            {
                if (计数 == 1)
                {
                    象棋数据.能否移动缓存[y][x + xx] = 数据::可移动标记;
                    break;
                }
                计数++;
            }
        }
        计数 = 0;
        for (int yy = 1; yy < 10 - y; yy++)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(yy, 0);
            if (缓存 == 数据::无 and 计数 == 0)
            {
                象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
            }
            if (缓存 != 数据::无)
            {
                if (计数 == 1)
                {
                    象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
                    break;
                }
                计数++;
            }
        }
        计数 = 0;
        for (int yy = -1; yy >= -1 * y; yy--)
        {
            缓存 = 象棋数据.判断原点偏移后是否有棋(yy, 0);
            if (缓存 == 数据::无 and 计数 == 0)
            {
                象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
            }
            if (缓存 != 数据::无)
            {
                if (计数 == 1)
                {
                    象棋数据.能否移动缓存[y + yy][x] = 数据::可移动标记;
                    break;
                }
                计数++;
            }
        }
        break;
    case 7:
        if (象棋数据.当前方>0)
        {
            if (y <= 4)
            {
                象棋数据.能否移动缓存[y + 1][x] = 数据::可移动标记;
            }
            if (y >= 5)
            {
                if (y!=9)
                {
                    象棋数据.能否移动缓存[y + 1][x] = 数据::可移动标记;
                }
                if (x >= 1)
                {
                    象棋数据.能否移动缓存[y][x + 1] = 数据::可移动标记;
                }
                if (x <= 8)
                {
                    象棋数据.能否移动缓存[y][x - 1] = 数据::可移动标记;
                }
            }
        }
        if (象棋数据.当前方 < 0)
        {
            if (y >= 4)
            {
                象棋数据.能否移动缓存[y - 1][x] = 数据::可移动标记;
            }
            if (y <= 4)
            {
                if (y != 0)
                {
                    象棋数据.能否移动缓存[y - 1][x] = 数据::可移动标记;
                }
                if (x >= 1)
                {
                    象棋数据.能否移动缓存[y][x + 1] = 数据::可移动标记;
                }
                if (x <= 8)
                {
                    象棋数据.能否移动缓存[y][x - 1] = 数据::可移动标记;
                }
            }
        }
        break;
    default:
        break;
    }
    for (int y = 0; y < 10; y++)
    {
        for (int x = 0; x < 9; x++)
        {
            if (象棋数据.当前棋子[y][x] * 象棋数据.当前方 < 0)
            {
                if (象棋数据.能否移动缓存[y][x]==数据::可移动标记)
                {
                    象棋数据.能否移动缓存[y][x] = 数据::可吃棋标记;
                }
            }
            if (象棋数据.当前棋子[y][x] * 象棋数据.当前方 > 0)
            {
                if (象棋数据.能否移动缓存[y][x] == 数据::可移动标记)
                {
                    象棋数据.能否移动缓存[y][x] = 数据::无;
                }
            }
        }
    }
    return 0;
}

int 保存操作到历史记录(象棋数据类& 象棋数据, 判断鼠标在网格位置 目标的网格,char 目标的棋子) {
    std::array <char,6>当前方操作;
    当前方操作[0] = 象棋数据.选取的棋子种类;
    当前方操作[1] = 象棋数据.选取的棋子坐标.y;
    当前方操作[2] = 象棋数据.选取的棋子坐标.x;
    当前方操作[3] = 目标的网格.网格位置.y;
    当前方操作[4] = 目标的网格.网格位置.x;
    当前方操作[5] = 目标的棋子;
    象棋数据.历史棋.push_back(当前方操作);
    return 0;
}

int 玩家操作(配置数据类& 配置数据, 象棋数据类& 象棋数据) {
    重新开始函数:
    while (配置数据.程序运行状态) {
        std::lock_guard<std::mutex> lock(eventMutex);
        while (!eventQueue.empty()) {
            // 从事件队列中获取事件并处理
            sf::Event event = eventQueue.front();
            eventQueue.pop();

            // 在这里处理窗口事件，例如关闭窗口、键盘输入等
            if (event.type == sf::Event::Closed) {
                // 处理关闭窗口事件
                // 可以执行一些清理操作并退出程序
                配置数据.程序运行状态 = 0;
                return 0;
            }
            // 处理鼠标左键按下事件
            if (event.type == sf::Event::MouseButtonPressed and event.mouseButton.button == sf::Mouse::Left){
                sf::Vector2f 网格原点 = { 配置数据.棋盘位置x * 配置数据.显示单元格大小, 配置数据.棋盘位置y * 配置数据.显示单元格大小 };
                判断鼠标在网格位置 鼠标选取的网格 = { 象棋数据.当前鼠标坐标, 网格原点, sf::Vector2i{ 配置数据.显示单元格大小, 配置数据.显示单元格大小 } ,sf::Vector2i(9,10)};
                if (!鼠标选取的网格.是否超出网格网格)
                {
                    char *原当前格棋子数据 = &象棋数据.当前棋子[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x];
                    char 当前单元格棋子 = 象棋数据.当前棋子[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x];
                    //拿起棋子
                    if (象棋数据.选取的棋子种类 == 0) {
                        if (象棋数据.当前方 > 0) {
                            if (当前单元格棋子 > 0) {
                                象棋数据.选取的棋子种类 = 当前单元格棋子;
                                象棋数据.选取的棋子坐标.y = 鼠标选取的网格.网格位置.y;
                                象棋数据.选取的棋子坐标.x = 鼠标选取的网格.网格位置.x;
                                判断移动合法性(鼠标选取的网格, 象棋数据);
                                *原当前格棋子数据 = 0;
                            }
                        }
                        else {
                            if (当前单元格棋子 < 0) {
                                象棋数据.选取的棋子种类 = 当前单元格棋子;
                                象棋数据.选取的棋子坐标.y = 鼠标选取的网格.网格位置.y;
                                象棋数据.选取的棋子坐标.x = 鼠标选取的网格.网格位置.x;
                                判断移动合法性(鼠标选取的网格, 象棋数据);
                                *原当前格棋子数据 = 0;
                            }
                        }
                    }

                    //放下棋子
                    if (象棋数据.选取的棋子种类 > 0)
                    {
                        if (当前单元格棋子 <= 0)
                        {
                            if (象棋数据.能否移动缓存[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x] == 数据::可吃棋标记 or 象棋数据.能否移动缓存[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x] == 数据::可移动标记)
                            //if(1)
                            {
                                if (*原当前格棋子数据 == -数据::将)
                                {
                                    象棋数据.重置数据(配置数据);
                                    //配置数据.游戏重开= true;
                                    //配置数据.程序运行状态 = false;
                                    goto 重新开始函数;
                                }
                                保存操作到历史记录(象棋数据,鼠标选取的网格, 象棋数据.当前棋子[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x]);  
                                *原当前格棋子数据 = 象棋数据.选取的棋子种类;
                                象棋数据.选取的棋子种类 = 0;
                                象棋数据.当前方 *= -1;
                                象棋数据.清空能否移动缓存();
                            }                          
                        }
                    }
                    if (象棋数据.选取的棋子种类 < 0)
                    {
                        if (当前单元格棋子 >= 0)
                        {
                            if (象棋数据.能否移动缓存[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x] == 数据::可吃棋标记 or 象棋数据.能否移动缓存[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x] == 数据::可移动标记)
                            //if (1)
                            {
                                if (*原当前格棋子数据 == 数据::将)
                                {
                                    象棋数据.重置数据(配置数据);
                                    //配置数据.游戏重开 = true;
                                    //配置数据.程序运行状态 = false;
                                    goto 重新开始函数;
                                }
                                    保存操作到历史记录(象棋数据, 鼠标选取的网格, 象棋数据.当前棋子[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x]);
                                *原当前格棋子数据 = 象棋数据.选取的棋子种类;
                                象棋数据.选取的棋子种类 = 0;
                                象棋数据.当前方 *= -1;
                                象棋数据.清空能否移动缓存();
                                
                            }
                        }
                    }
                }

            }

            // 处理鼠标左键释放事件
            if (event.type == sf::Event::MouseButtonReleased and event.mouseButton.button == sf::Mouse::Left)
            {
                //std::cout << "Left mouse button released at: " << event.mouseButton.x << ", " << event.mouseButton.y << std::endl;
            }

            // 处理鼠标右键按下事件
            if (event.type == sf::Event::MouseButtonPressed and event.mouseButton.button == sf::Mouse::Right)
            {
                sf::Vector2f 网格原点 = { 配置数据.棋盘位置x * 配置数据.显示单元格大小, 配置数据.棋盘位置y * 配置数据.显示单元格大小 };
                判断鼠标在网格位置 鼠标选取的网格 = { 象棋数据.当前鼠标坐标, 网格原点, sf::Vector2i{ 配置数据.显示单元格大小, 配置数据.显示单元格大小 } ,sf::Vector2i(9,10) };
                if (!鼠标选取的网格.是否超出网格网格)
                {
                    char* 原当前格棋子数据 = &象棋数据.当前棋子[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x];
                    char 当前单元格棋子 = 象棋数据.当前棋子[鼠标选取的网格.网格位置.y][鼠标选取的网格.网格位置.x];
                    if (象棋数据.选取的棋子种类 !=0)
                    {
                        象棋数据.当前棋子[象棋数据.选取的棋子坐标.y][象棋数据.选取的棋子坐标.x] = 象棋数据.选取的棋子种类;
                        象棋数据.选取的棋子种类 = 0;
                    }
                }
            }

            // 处理鼠标右键释放事件
            if (event.type == sf::Event::MouseButtonReleased and event.mouseButton.button == sf::Mouse::Right)
            {
                //std::cout << "Right mouse button released at: " << event.mouseButton.x << ", " << event.mouseButton.y << std::endl;
            }
            // 处理退格悔棋
            if (event.type == sf::Event::KeyPressed and event.key.code == sf::Keyboard::BackSpace)
            {
                if (象棋数据.历史棋.size()>=1)
                {
                    auto 上一步数据 = 象棋数据.历史棋[象棋数据.历史棋.size() - 1];
                    象棋数据.当前方 = 上一步数据[0];
                    象棋数据.选取的棋子种类 = 0;
                    象棋数据.当前棋子[上一步数据[1]][上一步数据[2]] = 上一步数据[0];
                    象棋数据.当前棋子[上一步数据[3]][上一步数据[4]] = 上一步数据[5];
                    象棋数据.历史棋.pop_back();
                }
            }
            // 处理ESC退出游戏
            if (event.type == sf::Event::KeyPressed and event.key.code == sf::Keyboard::Escape)
            {
                配置数据.程序运行状态 = false;
            }
        }
    }
    return 0;
}